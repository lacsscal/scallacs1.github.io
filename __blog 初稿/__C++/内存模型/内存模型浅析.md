##起
一直以来，虽然对寻址时查看到的不同的类型的内存位置(地址)存在挺大的区别感觉有些迷，
但是没有对他们进行整合在一起的区分，

这里写一篇blog对这些现象背后的C/C++内存模型做个整理。

##正文 分区
我了解到的C++内存模型

form 翁恺老师
	
	放对象的地方（stack heap 全局数据区）
	访问对象的方式 直接用 指针 引用
	三种放的地方 三种访问的方式 3*3=9种情况
	因此内存模型复杂
	[注]JAVA的对象都是通过new创建出来 所以都在堆上(heap),访问方式(const指针)即引用,内存模型简单[详细见笔记(cpp 引用)]

from 网络资源
	
	放对象的地方 更加细分
	1. 内存栈区： 存放局部变量名；
	2. 内存堆区： 存放new或者malloc出来的对象；
	3. 常数区： 存放局部变量或者全局变量的值；
	4. 静态区： 用于存放全局变量或者静态变量；
	5. 代码区：二进制代码。

from 网络第二

	理解为4个分区：
	1. 栈
	2. 堆
	3. 全局/静态存储区
	4. 常量存储区。
	
---
按3种存放区域划分方式分析内存模型

C/C++不提供垃圾回收机制，因此需要对**堆**中的数据进行及时销毁，

防止内存泄漏，使用free和delete销毁malloc和new申请的**堆**内存，

**栈**内存是动态释放。普通局部变量保存在栈中；

全局变量、静态局部变量保存在**全局数据区**，初始化的和未初始化的分别保存在一起；


	[注]
	堆栈 栈 都是指stack 由编译器自动分配释放
	堆 即 heap由程序员分配释放,对于长期运行或不关闭的程序，程序员不释放heap分配的资源，则有内存泄露风险
	全局数据区 编译器编译时即分配内存 已知全局变量 静态局部变量存在这里，按照细分的方式，这里叫静态区static
	[注]关于全局与静态
	把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。
	把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

按照细分的方式 多出来的两种分别是

文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 

程序代码区 —存放函数体的二进制代码。 
	

---
用一个程序来了解各个区域的变量情况
	
	#include <iostream>
	#include <string.h>
	
	using namespace std;

	int a = 0; 	//全局初始化区 
	char *p1; 	//全局未初始化区 
 
	int main(int argc, char const *argv[]) 
	{ 
	    cout << "a 全局变量初始化 : "<< &a << endl;
	    		// cout << "p1 全局指针未初始化: "<< p1 << endl;
	    int b;	// 栈 
	    cout << "b 本地变量 栈中 : "<< &b << endl;
	    char s[] = "abc"; 
				//"abc"在常量区，s在栈上。 
	    cout << "s 字符串常量初始化数组: "<< &s << "abc 用debug显示地址"  << endl;
	    char *p2; 
	    		// cout << "p2 本地变量指针 栈中 : "<< p2 << endl;
	    char *p3 = "123456"; 
				//123456\0";在常量区，p3在栈上。
	    cout << "*p3 字符串常量初始化指针所指: "<< s << "123456 用debug显示地址"  << endl;
	    static int c =0; 
				//全局（静态）初始化区 
	    cout << "c 静态变量 全局数据区(静态区) : "<< &c << endl;
	    p1 = (char *)malloc(10); 
	    p2 = (char *)malloc(20); 
				//分配得来得10和20字节的区域就在堆区。 
	    cout << "p1 全局初始化: "<< p1 << endl;
	    cout << "p2 本地变量指针 栈中 : "<< p2 << endl;
	    strcpy(p1, "123456");
				//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
	    return 0;
	} 

[各区域变量分布图123]()
[各区域变量分布图123]()
[各区域变量分布图123]()
	
	debug调试查看
	在程序中一共声明7个变量 a,b,c, s, p1,p2,p3
	其中
	a:初始化了的全局变量 			地址 0x407030
	b:栈中声明的本地变量 			地址 0x61fe0c
	c:静态局部变量	   			地址 0x407044
	s:栈中数组用字符串常量初始化	地址 0x61fe08
	p1:全局区声明的未初始化指针	地址 0x0(未初始化时)	0x23823b0(malloc初始化后)[有时是6开头]
	p2:栈中声明指针				地址 0x631cb0		0x23823f0(malloc初始化后)
	p3:栈中指针用字符串常量初始化	地址 0x10(未初始化时) 0x404074(字符串常量初始化后)

	综上：
	全局变量 静态变量 字符串常量在内存中位置相近 0x4... 应该为全局数据区
	栈中声明的变量(函数参数 本地变量etc) 0x6...
	堆中声明的变量(程序员分配) 0x2... 0x6...

---
## 补充 以下部分是一些网络上的资料
细分的5种分区
一个可执行程序文件需要在计算机硬件上运行起来，
其实质就是静态的文件被加载到内存中的过程，
可执行程序文件只是一个程序的载体

一个程序被加载到内存中，这块内存首先就存在两种属性：静态分配内存和动态分配内存。 

静态分配内存：是在程序编译和链接时就确定好的内存。 

动态分配内存：是在程序加载、调入、执行的时候分配/回收的内存。

	Text & Data & Bss
	.text：
		 也称为代码段(Code)，用来存放程序执行代码，
		 同时也可能会包含一些常量(如一些字符串常量等）。
		 该段内存为静态分配，只读(某些架构可能允许修改)。 
		 这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。
	
	.data： 也有的地方叫GVAR(global value)，用来存放程序中已经初始化的非零全局变量。静态分配。
	
		 data又可分为读写（RW）区域和只读（RO）区域。 
		 -> RO段保存常量所以也被称为.constdata 
		 -> RW段则是普通非常全局变量，静态变量就在其中

	.bss： 存放程序中为初始化的和零值全局变量。静态分配，在程序开始时通常会被清零。

text和data段都在可执行文件中，由系统从可执行文件中加载；
而bss段不在可执行文件中，由系统初始化。 
这三段内存就组成了我们编写的程序的本体，
但是一个程序运行起来，还需要更多的数据和数据间的交互，
否则这个程序就是死的，无用的。所以我们还需要为更多的数据和数据交互提供一块内存——堆heap 栈stack。
	
	Heap& Stack
	堆和栈都是动态分配内存，两者空间大小都是可变的。
	
	Stack： 
	栈，存放Automatic Variables，按内存地址由高到低方向生长，
	其最大大小由编译时确定，速度快，但自由性差，最大空间不大。
	
	Heap： 
	堆，自由申请的空间，按内存地址由低到高方向生长，
	其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 
	每个线程都会有自己的栈，但是堆空间是共用的。


[以上关系配图]()

这张图中所示内存空间，地址由下往上增长，分别标示了 .text、.data、.bss、stack和heap的内存分部情况。 
我们可以看到：

text、data(gvar)、bss 在内存中地址较低低的位置（low level address），而堆栈则在相对较高的位置。
堆(Heap)往高地址方向生长，栈(Stack)往低地址方向生长。



补充部分引用自
> https://blog.csdn.net/jirryzhang/article/details/79518408

## 4分区的情况+表格对比

1. 栈 stack
	
	编译期间就能确定存储大小的变量的存储区，
	在函数作用域内创建，在离开作用域后自动销毁的变量的存储区。
	通常是局部变量，函数参数等的存储区。
	存储空间是连续的  栈的大小是有限的，通常Visual C++编译器的默认栈的大小为1MB，
	所以不要定义int a[1000000]这样的超大数组。
2. 堆 heap
    
	在编译期间不能确定存储大小的变量的存储区，存储空间是不连续的，
	[程序员]来分配释放内存块，
	两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，
	所以会产生内存碎片。堆的大小几乎不受限制，理论上程序起来后会有完整的虚拟内存给它。

3. 全局/静态存储区
     
	和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，
	但它用于的是在整个程序运行期间都可见的全局变量和静态变量。

4 常量存储区
       
	和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，
	并且在程序运行期间，存储区内的常量是全局可见的。
	这是一块比较特殊的存储去，他们里面存放的是常量，不允许被修改。


| |栈|堆|
|---|:---:|---:|
|存储内容|局部变量|变量|
|作用域|函数作用域,语句块作用域|函数作用域,语句块作用域
|编译期间大小是否确定	|是|否
|大小	|1MB(栈帧)|4GB(虚拟内存)
|内存分配方式	|地址由高向低减少|地址由低向高增加
|内容是否可以修改	|是|是


静态存储区和常量存储区的对比


||全局/静态存储区|常量存储区|
|---|:---:|:---:|
|存储内容|全局变量、静态变量|常量
|编译期间大小是否确定|是|是
|内容是否可以修改|是|否

---
